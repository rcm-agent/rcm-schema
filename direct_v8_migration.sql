-- RCM V8 Direct Migration Script
-- Run this with: psql -U postgres -d rcm_db -f direct_v8_migration.sql

-- Start transaction
BEGIN;

-- Enable extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "vector";

-- 1. Create lookup tables
CREATE TABLE IF NOT EXISTS task_domain_lu (domain TEXT PRIMARY KEY);
INSERT INTO task_domain_lu(domain) VALUES
 ('eligibility'),('prior_auth'),('claim'),('payment'),('patient'),
 ('provider'),('billing'),('reporting'),('document')
ON CONFLICT DO NOTHING;

CREATE TABLE IF NOT EXISTS task_action_lu (action TEXT PRIMARY KEY);
INSERT INTO task_action_lu(action) VALUES
 ('check'),('verify'),('update'),('submit'),('check_status'),('appeal'),('extend'),
 ('submit_claim'),('status_check'),('resubmit'),('void'),('correct'),
 ('post'),('reconcile'),('adjust'),('refund'),
 ('search'),('register'),('update_demographics'),('verify_insurance'),
 ('credential'),('enroll'),('update_info'),
 ('generate_statement'),('send_invoice'),('apply_payment'),
 ('generate_report'),('export_data'),('analyze'),
 ('upload'),('download'),('parse'),('validate'),
 ('check_legacy'),('status_check_legacy')
ON CONFLICT DO NOTHING;

CREATE TABLE IF NOT EXISTS task_signature_source_lu (source TEXT PRIMARY KEY);
INSERT INTO task_signature_source_lu(source) VALUES
 ('human'),('ai_generated'),('system_learned')
ON CONFLICT DO NOTHING;

CREATE TABLE IF NOT EXISTS job_status_lu (status TEXT PRIMARY KEY);
INSERT INTO job_status_lu(status) VALUES
 ('pending'),('processing'),('completed'),('failed'),('partially_completed')
ON CONFLICT DO NOTHING;

CREATE TABLE IF NOT EXISTS requirement_type_lu (rtype TEXT PRIMARY KEY);
INSERT INTO requirement_type_lu(rtype) VALUES
 ('required'),('conditional'),('optional'),('output')
ON CONFLICT DO NOTHING;

CREATE TABLE IF NOT EXISTS user_role_lu (role TEXT PRIMARY KEY);
INSERT INTO user_role_lu(role) VALUES
 ('admin'),('operator'),('viewer'),('api_user'),
 ('org_admin'),('firm_user'),('hospital_user'),('sys_admin')
ON CONFLICT DO NOTHING;

-- 2. Create organization table
CREATE TABLE IF NOT EXISTS organization (
  org_id       UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_type     TEXT NOT NULL CHECK (org_type IN ('hospital','billing_firm','credentialer')),
  name         TEXT NOT NULL UNIQUE,
  email_domain TEXT UNIQUE,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Insert default organization
INSERT INTO organization (org_id, org_type, name, email_domain)
VALUES (gen_random_uuid(), 'billing_firm', 'Default Organization', 'default.com')
ON CONFLICT (name) DO NOTHING;

-- Store default org_id for use
DO $$
DECLARE
    default_org_id UUID;
BEGIN
    SELECT org_id INTO default_org_id FROM organization WHERE name = 'Default Organization';
    
    -- Store in temp table for use in this session
    CREATE TEMP TABLE IF NOT EXISTS migration_defaults (
        key TEXT PRIMARY KEY,
        value TEXT
    );
    INSERT INTO migration_defaults (key, value) VALUES ('default_org_id', default_org_id::TEXT);
END $$;

-- 3. Create channel_type and endpoint tables
CREATE TABLE IF NOT EXISTS channel_type (
  channel_type_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  code            TEXT UNIQUE,
  name            TEXT NOT NULL,
  base_url        TEXT,
  endpoint_kind   TEXT NOT NULL CHECK (endpoint_kind IN ('payer','provider','clearinghouse')),
  access_medium   TEXT NOT NULL CHECK (access_medium IN ('web','phone','fax','efax','edi'))
);

CREATE TABLE IF NOT EXISTS endpoint (
  endpoint_id     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  org_id          UUID NOT NULL REFERENCES organization(org_id) ON DELETE CASCADE,
  name            TEXT NOT NULL,
  channel_type_id BIGINT NOT NULL REFERENCES channel_type(channel_type_id),
  base_url        TEXT,
  config          JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (org_id, name),
  UNIQUE (org_id, channel_type_id)
);

-- 4. Create workflow tables
CREATE TABLE IF NOT EXISTS workflow_node (
  node_id       BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  code          TEXT UNIQUE,
  description   TEXT,
  metadata      JSONB DEFAULT '{}'::jsonb,
  label_conf    NUMERIC(3,2),
  last_label_at TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS workflow_transition (
  from_node    BIGINT REFERENCES workflow_node(node_id) ON DELETE CASCADE,
  to_node      BIGINT REFERENCES workflow_node(node_id) ON DELETE CASCADE,
  action_label TEXT NOT NULL,
  freq         INT NOT NULL DEFAULT 1 CHECK (freq >= 1),
  PRIMARY KEY (from_node, to_node, action_label)
);

CREATE TABLE IF NOT EXISTS user_workflow (
  workflow_id   UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name          TEXT NOT NULL,
  description   TEXT,
  required_data JSONB DEFAULT '[]'::jsonb,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS micro_state (
  micro_state_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  workflow_id    UUID NOT NULL REFERENCES user_workflow(workflow_id) ON DELETE CASCADE,
  node_id        BIGINT NOT NULL REFERENCES workflow_node(node_id),
  dom_snapshot   TEXT NOT NULL,
  action_json    JSONB NOT NULL,
  semantic_spec  JSONB,
  label          TEXT,
  category       TEXT,
  required       BOOLEAN DEFAULT FALSE,
  is_dynamic     BOOLEAN GENERATED ALWAYS AS ((semantic_spec -> 'dynamic_meta') IS NOT NULL) STORED,
  text_emb       VECTOR(768) NOT NULL,
  mini_score     NUMERIC(4,3),
  is_retired     BOOLEAN NOT NULL DEFAULT false,
  aliased_to     BIGINT REFERENCES micro_state(micro_state_id),
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 5. Bridge tables
CREATE TABLE IF NOT EXISTS user_workflow_channel_type (
  workflow_id     UUID REFERENCES user_workflow(workflow_id) ON DELETE CASCADE,
  channel_type_id BIGINT REFERENCES channel_type(channel_type_id) ON DELETE CASCADE,
  timeout_ms      INT,
  priority        SMALLINT,
  PRIMARY KEY (workflow_id, channel_type_id)
);

CREATE TABLE IF NOT EXISTS user_workflow_task_type (
  workflow_id  UUID REFERENCES user_workflow(workflow_id) ON DELETE CASCADE,
  task_type_id UUID REFERENCES task_type(task_type_id) ON DELETE CASCADE,
  preferred    BOOLEAN DEFAULT false,
  PRIMARY KEY (workflow_id, task_type_id)
);

-- 6. Rename rcm_user to app_user (if exists)
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'rcm_user') THEN
        -- Add new columns first
        ALTER TABLE rcm_user ADD COLUMN IF NOT EXISTS org_id UUID;
        ALTER TABLE rcm_user ADD COLUMN IF NOT EXISTS user_id UUID DEFAULT gen_random_uuid();
        
        -- Update with default org
        UPDATE rcm_user 
        SET org_id = (SELECT value::UUID FROM migration_defaults WHERE key = 'default_org_id')
        WHERE org_id IS NULL;
        
        -- Rename table
        ALTER TABLE rcm_user RENAME TO app_user;
        
        -- Update constraints
        ALTER TABLE app_user DROP CONSTRAINT IF EXISTS rcm_user_pkey;
        ALTER TABLE app_user ADD PRIMARY KEY (user_id);
        
        -- Make org_id NOT NULL
        ALTER TABLE app_user ALTER COLUMN org_id SET NOT NULL;
    ELSE
        -- Create new app_user table
        CREATE TABLE app_user (
          user_id    UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          org_id     UUID REFERENCES organization(org_id) ON DELETE CASCADE NOT NULL,
          email      TEXT NOT NULL UNIQUE,
          full_name  TEXT,
          role       TEXT NOT NULL REFERENCES user_role_lu(role),
          is_active  BOOLEAN NOT NULL DEFAULT true,
          api_key_ssm_parameter_name VARCHAR(512),
          created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
          updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
          last_login_at TIMESTAMPTZ
        );
    END IF;
END $$;

-- 7. Create workflow_trace and bridge table
CREATE TABLE IF NOT EXISTS workflow_trace (
  trace_id      BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  batch_job_item_id UUID,
  org_id         UUID NOT NULL REFERENCES organization(org_id),
  workflow_id    UUID REFERENCES user_workflow(workflow_id),
  action_type    TEXT,
  action_detail  JSONB,
  success        BOOLEAN DEFAULT false,
  duration_ms    INT,
  error_detail   JSONB,
  llm_prompt     TEXT,
  llm_response   TEXT,
  llm_model      VARCHAR(100),
  llm_tokens_used INT,
  tier           SMALLINT,
  tier_reason    TEXT,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  user_id        UUID REFERENCES app_user(user_id),
  session_id     UUID
);

CREATE TABLE IF NOT EXISTS workflow_trace_endpoint (
  trace_id    BIGINT NOT NULL REFERENCES workflow_trace(trace_id) ON DELETE CASCADE,
  endpoint_id BIGINT NOT NULL REFERENCES endpoint(endpoint_id) ON DELETE CASCADE,
  PRIMARY KEY (trace_id, endpoint_id)
);

-- 8. Update existing tables to use lookup tables
DO $$
BEGIN
    -- Update task_type if it exists
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_type') THEN
        ALTER TABLE task_type RENAME COLUMN id TO task_type_id;
        -- Add foreign keys to lookup tables
        ALTER TABLE task_type ADD CONSTRAINT fk_task_type_domain 
            FOREIGN KEY (domain) REFERENCES task_domain_lu(domain);
        ALTER TABLE task_type ADD CONSTRAINT fk_task_type_action 
            FOREIGN KEY (action) REFERENCES task_action_lu(action);
    END IF;
    
    -- Update field_requirement if it exists
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'field_requirement') THEN
        ALTER TABLE field_requirement RENAME COLUMN id TO field_req_id;
        -- Add foreign keys
        ALTER TABLE field_requirement ADD CONSTRAINT fk_field_req_type 
            FOREIGN KEY (requirement_type) REFERENCES requirement_type_lu(rtype);
        ALTER TABLE field_requirement ADD CONSTRAINT fk_field_req_source 
            FOREIGN KEY (source) REFERENCES task_signature_source_lu(source);
    END IF;
    
    -- Update batch_job if it exists
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'batch_job') THEN
        ALTER TABLE batch_job RENAME COLUMN id TO batch_job_id;
        ALTER TABLE batch_job ADD CONSTRAINT fk_batch_job_status 
            FOREIGN KEY (status) REFERENCES job_status_lu(status);
    END IF;
    
    -- Update batch_job_item if it exists
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'batch_job_item') THEN
        ALTER TABLE batch_job_item RENAME COLUMN id TO batch_job_item_id;
        ALTER TABLE batch_job_item ADD CONSTRAINT fk_batch_item_status 
            FOREIGN KEY (status) REFERENCES job_status_lu(status);
    END IF;
END $$;

-- 9. Create backward compatibility views
CREATE OR REPLACE VIEW rcm_user AS
SELECT 
    user_id as id,
    email,
    full_name,
    role,
    is_active,
    api_key_ssm_parameter_name,
    created_at,
    updated_at,
    last_login_at
FROM app_user;

CREATE OR REPLACE VIEW rcm_trace AS
SELECT 
    trace_id as id,
    batch_job_item_id,
    (SELECT ct.code FROM workflow_trace_endpoint wte 
     JOIN endpoint e ON wte.endpoint_id = e.endpoint_id
     JOIN channel_type ct ON e.channel_type_id = ct.channel_type_id
     WHERE wte.trace_id = workflow_trace.trace_id
     LIMIT 1) as portal_id,
    action_type,
    action_detail,
    success,
    duration_ms,
    error_detail,
    llm_prompt,
    llm_response,
    llm_model,
    llm_tokens_used,
    created_at,
    user_id,
    session_id
FROM workflow_trace;

-- 10. Create indexes
CREATE INDEX IF NOT EXISTS idx_endpoint_org ON endpoint(org_id);
CREATE INDEX IF NOT EXISTS idx_app_user_org ON app_user(org_id);
CREATE INDEX IF NOT EXISTS idx_micro_state_node ON micro_state(node_id);
CREATE INDEX IF NOT EXISTS idx_trace_org ON workflow_trace(org_id);
CREATE INDEX IF NOT EXISTS idx_trace_created ON workflow_trace(created_at DESC);

-- Vector index (if pgvector is available)
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_micro_state_text_hnsw ON micro_state
    USING hnsw (text_emb vector_cosine_ops)
    WITH (m = 16, ef_construction = 64)
    WHERE is_retired = false;
EXCEPTION
    WHEN undefined_object THEN
        RAISE NOTICE 'pgvector not available, skipping vector index';
END $$;

-- 11. Update triggers
CREATE OR REPLACE FUNCTION update_timestamp() RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply update triggers
DO $$
BEGIN
    -- Drop existing triggers first
    DROP TRIGGER IF EXISTS update_app_user_updated_at ON app_user;
    DROP TRIGGER IF EXISTS update_user_workflow_updated_at ON user_workflow;
    DROP TRIGGER IF EXISTS update_task_type_updated_at ON task_type;
    DROP TRIGGER IF EXISTS update_field_requirement_updated_at ON field_requirement;
    DROP TRIGGER IF EXISTS update_batch_job_updated_at ON batch_job;
    DROP TRIGGER IF EXISTS update_batch_job_item_updated_at ON batch_job_item;
    
    -- Create new triggers
    CREATE TRIGGER update_app_user_updated_at BEFORE UPDATE ON app_user 
        FOR EACH ROW EXECUTE FUNCTION update_timestamp();
    CREATE TRIGGER update_user_workflow_updated_at BEFORE UPDATE ON user_workflow 
        FOR EACH ROW EXECUTE FUNCTION update_timestamp();
    
    -- Only create if tables exist
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'task_type') THEN
        CREATE TRIGGER update_task_type_updated_at BEFORE UPDATE ON task_type 
            FOR EACH ROW EXECUTE FUNCTION update_timestamp();
    END IF;
    
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'field_requirement') THEN
        CREATE TRIGGER update_field_requirement_updated_at BEFORE UPDATE ON field_requirement 
            FOR EACH ROW EXECUTE FUNCTION update_timestamp();
    END IF;
    
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'batch_job') THEN
        CREATE TRIGGER update_batch_job_updated_at BEFORE UPDATE ON batch_job 
            FOR EACH ROW EXECUTE FUNCTION update_timestamp();
    END IF;
    
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'batch_job_item') THEN
        CREATE TRIGGER update_batch_job_item_updated_at BEFORE UPDATE ON batch_job_item 
            FOR EACH ROW EXECUTE FUNCTION update_timestamp();
    END IF;
END $$;

-- Migration complete
SELECT 'V8 Migration completed successfully!' as status;

-- Show summary
SELECT 
    'Tables created' as metric,
    COUNT(*) as count
FROM information_schema.tables
WHERE table_schema = 'public' 
AND table_name IN ('organization', 'channel_type', 'endpoint', 'workflow_node', 
                   'micro_state', 'app_user', 'workflow_trace')
UNION ALL
SELECT 
    'Compatibility views',
    COUNT(*)
FROM information_schema.views
WHERE table_schema = 'public'
AND table_name IN ('rcm_user', 'rcm_trace');

COMMIT;