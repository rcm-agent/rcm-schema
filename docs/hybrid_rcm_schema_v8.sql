-- Hybrid RCM Platform V8 Schema
-- Multi-tenant, graph workflows, ML-powered state management
-- PostgreSQL 16+ with pgvector extension

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "vector";

-- ================================================================
-- LOOKUP TABLES (Replacing ENUMs for runtime flexibility)
-- ================================================================

-- Task domains
CREATE TABLE task_domain_lu (
    domain TEXT PRIMARY KEY
);

INSERT INTO task_domain_lu(domain) VALUES
    ('eligibility'),
    ('prior_auth'),
    ('claim'),
    ('payment'),
    ('patient'),
    ('provider'),
    ('billing'),
    ('reporting'),
    ('document');

-- Task actions
CREATE TABLE task_action_lu (
    action TEXT PRIMARY KEY
);

INSERT INTO task_action_lu(action) VALUES
    ('check'),
    ('verify'),
    ('update'),
    ('submit'),
    ('check_status'),
    ('appeal'),
    ('extend'),
    ('submit_claim'),
    ('status_check'),
    ('resubmit'),
    ('void'),
    ('correct'),
    ('post'),
    ('reconcile'),
    ('adjust'),
    ('refund'),
    ('search'),
    ('register'),
    ('update_demographics'),
    ('verify_insurance'),
    ('credential'),
    ('enroll'),
    ('update_info'),
    ('generate_statement'),
    ('send_invoice'),
    ('apply_payment'),
    ('generate_report'),
    ('export_data'),
    ('analyze'),
    ('upload'),
    ('download'),
    ('parse'),
    ('validate'),
    ('check_legacy'),
    ('status_check_legacy');

-- Task signature sources
CREATE TABLE task_signature_source_lu (
    source TEXT PRIMARY KEY
);

INSERT INTO task_signature_source_lu(source) VALUES
    ('human'),
    ('ai_generated'),
    ('system_learned');

-- Job statuses
CREATE TABLE job_status_lu (
    status TEXT PRIMARY KEY
);

INSERT INTO job_status_lu(status) VALUES
    ('pending'),
    ('processing'),
    ('completed'),
    ('failed'),
    ('partially_completed');

-- Requirement types
CREATE TABLE requirement_type_lu (
    rtype TEXT PRIMARY KEY
);

INSERT INTO requirement_type_lu(rtype) VALUES
    ('required'),
    ('conditional'),
    ('optional'),
    ('output');

-- User roles
CREATE TABLE user_role_lu (
    role TEXT PRIMARY KEY
);

INSERT INTO user_role_lu(role) VALUES
    ('admin'),
    ('operator'),
    ('viewer'),
    ('api_user'),
    ('org_admin'),
    ('firm_user'),
    ('hospital_user'),
    ('sys_admin');

-- Organization types
CREATE TABLE org_type_lu (
    org_type TEXT PRIMARY KEY
);

INSERT INTO org_type_lu(org_type) VALUES
    ('hospital'),
    ('billing_firm'),
    ('credentialer');

-- Channel auth types
CREATE TABLE channel_auth_type_lu (
    auth_type TEXT PRIMARY KEY
);

INSERT INTO channel_auth_type_lu(auth_type) VALUES
    ('username_password'),
    ('oauth2'),
    ('api_key'),
    ('certificate'),
    ('saml');

-- Workflow statuses
CREATE TABLE workflow_status_lu (
    status TEXT PRIMARY KEY
);

INSERT INTO workflow_status_lu(status) VALUES
    ('draft'),
    ('active'),
    ('suspended'),
    ('completed'),
    ('archived');

-- ================================================================
-- MULTI-TENANT CORE TABLES
-- ================================================================

-- Organizations (multi-tenancy root)
CREATE TABLE organization (
    org_id       UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_type     TEXT NOT NULL REFERENCES org_type_lu(org_type),
    name         TEXT NOT NULL UNIQUE,
    email_domain TEXT UNIQUE,
    created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Application users (renamed from rcm_user)
CREATE TABLE app_user (
    user_id                     UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id                      UUID NOT NULL REFERENCES organization(org_id) ON DELETE CASCADE,
    email                       TEXT NOT NULL UNIQUE,
    full_name                   TEXT NOT NULL,
    role                        TEXT NOT NULL REFERENCES user_role_lu(role),
    is_active                   BOOLEAN NOT NULL DEFAULT true,
    api_key_ssm_parameter_name  TEXT,
    created_at                  TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at                  TIMESTAMPTZ NOT NULL DEFAULT now(),
    last_login_at               TIMESTAMPTZ
);

CREATE INDEX idx_app_user_org ON app_user(org_id);
CREATE INDEX idx_app_user_email ON app_user(email);

-- ================================================================
-- CHANNEL & ENDPOINT ABSTRACTION
-- ================================================================

-- Channel types (portal catalog)
CREATE TABLE channel_type (
    channel_type_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code            TEXT UNIQUE,
    name            TEXT NOT NULL,
    base_url        TEXT,
    endpoint_kind   TEXT NOT NULL CHECK (endpoint_kind IN ('payer','provider','clearinghouse')),
    access_medium   TEXT NOT NULL CHECK (access_medium IN ('web','phone','fax','efax','edi'))
);

-- Organization-specific endpoints
CREATE TABLE endpoint (
    endpoint_id     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    org_id          UUID NOT NULL REFERENCES organization(org_id) ON DELETE CASCADE,
    name            TEXT NOT NULL,
    channel_type_id BIGINT NOT NULL REFERENCES channel_type(channel_type_id),
    base_url        TEXT,
    config          JSONB NOT NULL DEFAULT '{}'::jsonb,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    UNIQUE (org_id, name),
    UNIQUE (org_id, channel_type_id)
);

CREATE INDEX idx_endpoint_org ON endpoint(org_id);
CREATE INDEX idx_endpoint_channel ON endpoint(channel_type_id);

-- Portal credentials (updated for endpoints)
CREATE TABLE portal_credential (
    credential_id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    endpoint_id           BIGINT NOT NULL REFERENCES endpoint(endpoint_id) ON DELETE CASCADE,
    account_id            TEXT NOT NULL,
    encrypted_credential  JSONB NOT NULL,
    credential_type       TEXT CHECK (credential_type IN ('user_pass', 'token', 'oauth2')),
    expires_at            TIMESTAMPTZ,
    last_validated_at     TIMESTAMPTZ,
    is_active             BOOLEAN NOT NULL DEFAULT true,
    validation_error      TEXT,
    created_at            TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at            TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by            UUID REFERENCES app_user(user_id),
    ssm_parameter_name    TEXT,
    last_rotation_at      TIMESTAMPTZ,
    rotation_status       TEXT CHECK (rotation_status IN ('pending', 'in_progress', 'completed', 'failed'))
);

CREATE INDEX idx_portal_cred_endpoint_account ON portal_credential(endpoint_id, account_id);
CREATE INDEX idx_portal_cred_active ON portal_credential(is_active) WHERE is_active;
CREATE INDEX idx_portal_cred_expires ON portal_credential(expires_at) WHERE expires_at IS NOT NULL;

-- ================================================================
-- GRAPH-BASED WORKFLOW TABLES
-- ================================================================

-- Workflow nodes (DAG vertices)
CREATE TABLE workflow_node (
    node_id       BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code          TEXT UNIQUE,
    description   TEXT,
    metadata      JSONB DEFAULT '{}'::jsonb,
    label_conf    NUMERIC(3,2) CHECK (label_conf >= 0 AND label_conf <= 1),
    last_label_at TIMESTAMPTZ
);

-- Workflow transitions (DAG edges)
CREATE TABLE workflow_transition (
    from_node    BIGINT REFERENCES workflow_node(node_id) ON DELETE CASCADE,
    to_node      BIGINT REFERENCES workflow_node(node_id) ON DELETE CASCADE,
    action_label TEXT NOT NULL,
    freq         INTEGER NOT NULL DEFAULT 1 CHECK (freq >= 1),
    PRIMARY KEY (from_node, to_node, action_label)
);

CREATE INDEX idx_transition_from ON workflow_transition(from_node);
CREATE INDEX idx_transition_to ON workflow_transition(to_node);

-- User workflows (instances)
CREATE TABLE user_workflow (
    workflow_id   UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name          TEXT NOT NULL,
    description   TEXT,
    required_data JSONB DEFAULT '[]'::jsonb,
    created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Micro states (UI states with embeddings)
CREATE TABLE micro_state (
    micro_state_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    workflow_id    UUID NOT NULL REFERENCES user_workflow(workflow_id) ON DELETE CASCADE,
    node_id        BIGINT NOT NULL REFERENCES workflow_node(node_id),
    dom_snapshot   TEXT NOT NULL,
    action_json    JSONB NOT NULL,
    semantic_spec  JSONB,
    label          TEXT,
    category       TEXT,
    required       BOOLEAN DEFAULT FALSE,
    is_dynamic     BOOLEAN GENERATED ALWAYS AS ((semantic_spec -> 'dynamic_meta') IS NOT NULL) STORED,
    text_emb       vector(768) NOT NULL,  -- 768D embeddings for V8
    mini_score     NUMERIC(4,3) CHECK (mini_score >= 0 AND mini_score <= 1),
    is_retired     BOOLEAN NOT NULL DEFAULT false,
    aliased_to     BIGINT REFERENCES micro_state(micro_state_id),
    created_at     TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_micro_state_node ON micro_state(node_id);
CREATE INDEX idx_micro_state_workflow ON micro_state(workflow_id);
CREATE INDEX idx_micro_state_text_hnsw ON micro_state 
    USING hnsw (text_emb vector_cosine_ops)
    WITH (m = 16, ef_construction = 64)
    WHERE is_retired = false;

-- ================================================================
-- TASK & REQUIREMENTS TABLES
-- ================================================================

-- Task types (workflow templates)
CREATE TABLE task_type (
    task_type_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain       TEXT NOT NULL REFERENCES task_domain_lu(domain),
    action       TEXT NOT NULL REFERENCES task_action_lu(action),
    display_name TEXT NOT NULL,
    description  TEXT,
    created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
    UNIQUE (domain, action)
);

-- Field requirements (being phased out)
CREATE TABLE field_requirement (
    field_req_id      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_type_id      UUID NOT NULL REFERENCES task_type(task_type_id),
    portal_id         BIGINT REFERENCES endpoint(endpoint_id),
    requirement_type  TEXT NOT NULL REFERENCES requirement_type_lu(rtype),
    field_name        TEXT NOT NULL,
    field_label       TEXT,
    field_type        TEXT CHECK (field_type IN ('text', 'date', 'select', 'number', 'boolean')),
    is_array          BOOLEAN NOT NULL DEFAULT false,
    parent_id         UUID REFERENCES field_requirement(field_req_id),
    path              TEXT NOT NULL,
    depth             INTEGER NOT NULL DEFAULT 0,
    display_order     INTEGER,
    validation_rules  JSONB DEFAULT '{}'::jsonb,
    conditional_on    JSONB,
    source            TEXT NOT NULL REFERENCES task_signature_source_lu(source),
    created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_field_req_task_type ON field_requirement(task_type_id);
CREATE INDEX idx_field_req_parent ON field_requirement(parent_id) WHERE parent_id IS NOT NULL;
CREATE INDEX idx_field_req_path ON field_requirement(task_type_id, path);
CREATE INDEX idx_field_req_depth ON field_requirement(depth);

-- Task signatures (execution patterns)
CREATE TABLE task_signature (
    signature_id    UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain          TEXT NOT NULL REFERENCES task_domain_lu(domain),
    action          TEXT NOT NULL REFERENCES task_action_lu(action),
    portal_id       BIGINT REFERENCES endpoint(endpoint_id),
    alias_of        UUID REFERENCES task_signature(signature_id),
    signature_key   TEXT GENERATED ALWAYS AS (
        COALESCE(portal_id::text, 'global') || ':' || domain || ':' || action
    ) STORED UNIQUE,
    source          TEXT NOT NULL REFERENCES task_signature_source_lu(source),
    last_human_run  TIMESTAMPTZ,
    total_runs      INTEGER NOT NULL DEFAULT 0,
    success_runs    INTEGER NOT NULL DEFAULT 0,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_signature_portal ON task_signature(portal_id);
CREATE INDEX idx_signature_alias ON task_signature(alias_of) WHERE alias_of IS NOT NULL;

-- ================================================================
-- EXECUTION & TRACE TABLES
-- ================================================================

-- Batch jobs (multi-tenant)
CREATE TABLE batch_job (
    batch_job_id    BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    org_id          UUID NOT NULL REFERENCES organization(org_id) ON DELETE CASCADE,
    prompt          TEXT NOT NULL,
    file_name       TEXT,
    file_path       TEXT,
    total_rows      INTEGER NOT NULL DEFAULT 0,
    processed_rows  INTEGER NOT NULL DEFAULT 0,
    successful_rows INTEGER NOT NULL DEFAULT 0,
    failed_rows     INTEGER NOT NULL DEFAULT 0,
    status          TEXT NOT NULL REFERENCES job_status_lu(status),
    created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    completed_at    TIMESTAMPTZ,
    created_by      UUID REFERENCES app_user(user_id)
);

CREATE INDEX idx_batch_job_org ON batch_job(org_id);
CREATE INDEX idx_batch_job_status ON batch_job(status);

-- Batch job items
CREATE TABLE batch_job_item (
    batch_job_item_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    batch_job_id      BIGINT NOT NULL REFERENCES batch_job(batch_job_id) ON DELETE CASCADE,
    row_number        INTEGER NOT NULL,
    input_data        JSONB NOT NULL,
    output_data       JSONB,
    status            TEXT NOT NULL REFERENCES job_status_lu(status),
    error_message     TEXT,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
    completed_at      TIMESTAMPTZ
);

CREATE INDEX idx_batch_item_job ON batch_job_item(batch_job_id);
CREATE INDEX idx_batch_item_status ON batch_job_item(status);

-- Workflow traces (execution logs)
CREATE TABLE workflow_trace (
    trace_id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    org_id            UUID NOT NULL REFERENCES organization(org_id) ON DELETE CASCADE,
    workflow_id       UUID REFERENCES user_workflow(workflow_id),
    batch_job_item_id BIGINT REFERENCES batch_job_item(batch_job_item_id),
    action_type       TEXT NOT NULL,
    action_detail     JSONB,
    success           BOOLEAN NOT NULL DEFAULT false,
    duration_ms       INTEGER,
    error_detail      TEXT,
    llm_prompt        TEXT,
    llm_response      TEXT,
    llm_model         TEXT,
    llm_tokens_used   INTEGER,
    tier              SMALLINT CHECK (tier IN (1, 2, 3)),
    tier_reason       TEXT,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
    user_id           UUID REFERENCES app_user(user_id),
    session_id        TEXT
);

CREATE INDEX idx_trace_org ON workflow_trace(org_id);
CREATE INDEX idx_trace_workflow ON workflow_trace(workflow_id);
CREATE INDEX idx_trace_created ON workflow_trace(created_at DESC);

-- Workflow trace endpoints (multi-endpoint support)
CREATE TABLE workflow_trace_endpoint (
    trace_id    BIGINT NOT NULL REFERENCES workflow_trace(trace_id) ON DELETE CASCADE,
    endpoint_id BIGINT NOT NULL REFERENCES endpoint(endpoint_id) ON DELETE CASCADE,
    PRIMARY KEY (trace_id, endpoint_id)
);

-- ================================================================
-- STATE MEMORY TABLES (Legacy compatibility)
-- ================================================================

-- Macro states (state clusters)
CREATE TABLE macro_state (
    macro_state_id  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    portal_id       BIGINT REFERENCES endpoint(endpoint_id),
    action_type     TEXT NOT NULL,
    name            TEXT NOT NULL,
    summary_prompt  TEXT,
    count           INTEGER NOT NULL DEFAULT 0,
    created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- RCM states (legacy)
CREATE TABLE rcm_state (
    state_id                 BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    url                      TEXT NOT NULL,
    action_type              TEXT NOT NULL,
    dom_snapshot             TEXT,
    screenshot               BYTEA,
    llm_state_summary        TEXT,
    text_embedding           vector(768),
    screenshot_embedding     vector(512),
    macro_state_id           BIGINT REFERENCES macro_state(macro_state_id),
    last_human_validation_at TIMESTAMPTZ,
    created_at               TIMESTAMPTZ NOT NULL DEFAULT now(),
    task_type_id             UUID REFERENCES task_type(task_type_id),
    task_signature_id        UUID REFERENCES task_signature(signature_id),
    UNIQUE (url, action_type)
);

-- RCM transitions (state graph)
CREATE TABLE rcm_transition (
    from_state_id    BIGINT NOT NULL REFERENCES rcm_state(state_id),
    to_state_id      BIGINT NOT NULL REFERENCES rcm_state(state_id),
    action_taken     TEXT NOT NULL,
    frequency        INTEGER NOT NULL DEFAULT 1,
    last_observed_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
    PRIMARY KEY (from_state_id, to_state_id, action_taken)
);

-- ================================================================
-- HIERARCHICAL REQUIREMENTS SYSTEM
-- ================================================================

-- Payer requirements
CREATE TABLE payer_requirement (
    payer_requirement_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    payer_name           TEXT NOT NULL,
    task_type_id         UUID NOT NULL REFERENCES task_type(task_type_id),
    requirement_type     TEXT NOT NULL REFERENCES requirement_type_lu(rtype),
    field_name           TEXT NOT NULL,
    field_label          TEXT,
    field_type           TEXT CHECK (field_type IN ('text', 'date', 'select', 'number', 'boolean')),
    is_array             BOOLEAN NOT NULL DEFAULT false,
    validation_rules     JSONB DEFAULT '{}'::jsonb,
    effective_date       DATE NOT NULL DEFAULT CURRENT_DATE,
    end_date             DATE,
    created_at           TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by           UUID REFERENCES app_user(user_id),
    UNIQUE (payer_name, task_type_id, field_name, effective_date)
);

-- Organization requirement policies
CREATE TABLE org_requirement_policy (
    policy_id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id            UUID NOT NULL REFERENCES organization(org_id),
    task_type_id      UUID NOT NULL REFERENCES task_type(task_type_id),
    field_name        TEXT NOT NULL,
    override_action   TEXT NOT NULL CHECK (override_action IN ('add', 'remove', 'modify')),
    requirement_type  TEXT REFERENCES requirement_type_lu(rtype),
    field_label       TEXT,
    field_type        TEXT CHECK (field_type IN ('text', 'date', 'select', 'number', 'boolean')),
    is_array          BOOLEAN DEFAULT false,
    validation_rules  JSONB DEFAULT '{}'::jsonb,
    reason            TEXT,
    approved_by       UUID REFERENCES app_user(user_id),
    approved_at       TIMESTAMPTZ,
    effective_date    DATE NOT NULL DEFAULT CURRENT_DATE,
    end_date          DATE,
    created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by        UUID REFERENCES app_user(user_id),
    UNIQUE (org_id, task_type_id, field_name, effective_date)
);

-- Requirement changelog
CREATE TABLE requirement_changelog (
    changelog_id    UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_type     TEXT NOT NULL CHECK (entity_type IN ('payer', 'org')),
    entity_id       UUID NOT NULL,
    task_type_id    UUID NOT NULL REFERENCES task_type(task_type_id),
    field_name      TEXT NOT NULL,
    change_type     TEXT NOT NULL CHECK (change_type IN ('add', 'modify', 'remove')),
    old_value       JSONB,
    new_value       JSONB,
    changed_by      UUID NOT NULL REFERENCES app_user(user_id),
    changed_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    change_reason   TEXT
);

-- ================================================================
-- BACKWARD COMPATIBILITY VIEWS
-- ================================================================

-- View for legacy rcm_user table
CREATE OR REPLACE VIEW rcm_user AS
SELECT 
    user_id as id,
    email,
    full_name,
    role,
    is_active,
    api_key_ssm_parameter_name,
    created_at,
    updated_at,
    last_login_at
FROM app_user;

-- View for legacy rcm_trace table
CREATE OR REPLACE VIEW rcm_trace AS
SELECT 
    trace_id as id,
    batch_job_item_id,
    (SELECT ct.code FROM workflow_trace_endpoint wte 
     JOIN endpoint e ON wte.endpoint_id = e.endpoint_id
     JOIN channel_type ct ON e.channel_type_id = ct.channel_type_id
     WHERE wte.trace_id = workflow_trace.trace_id
     LIMIT 1) as portal_id,
    action_type,
    action_detail,
    success,
    duration_ms,
    error_detail,
    llm_prompt,
    llm_response,
    llm_model,
    llm_tokens_used,
    created_at,
    user_id,
    session_id
FROM workflow_trace;

-- ================================================================
-- ROW LEVEL SECURITY POLICIES
-- ================================================================

-- Enable RLS on tenant tables
ALTER TABLE app_user ENABLE ROW LEVEL SECURITY;
ALTER TABLE endpoint ENABLE ROW LEVEL SECURITY;
ALTER TABLE batch_job ENABLE ROW LEVEL SECURITY;
ALTER TABLE workflow_trace ENABLE ROW LEVEL SECURITY;

-- Example RLS policies (customize based on your auth system)
-- CREATE POLICY "Users see own org" ON app_user
--     FOR ALL USING (org_id = current_setting('app.current_org_id')::uuid);

-- CREATE POLICY "Users see own org endpoints" ON endpoint
--     FOR ALL USING (org_id = current_setting('app.current_org_id')::uuid);

-- ================================================================
-- FUNCTIONS AND TRIGGERS
-- ================================================================

-- Update timestamp trigger
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply update trigger to relevant tables
CREATE TRIGGER update_app_user_updated_at BEFORE UPDATE ON app_user
    FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_portal_credential_updated_at BEFORE UPDATE ON portal_credential
    FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_batch_job_updated_at BEFORE UPDATE ON batch_job
    FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_batch_job_item_updated_at BEFORE UPDATE ON batch_job_item
    FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- ================================================================
-- INITIAL DATA
-- ================================================================

-- Default organization (for migration)
INSERT INTO organization (org_type, name, email_domain)
VALUES ('billing_firm', 'Default Organization', 'default.com')
ON CONFLICT (name) DO NOTHING;

-- Sample channel types
INSERT INTO channel_type (code, name, endpoint_kind, access_medium) VALUES
    ('anthem_availity', 'Anthem via Availity', 'payer', 'web'),
    ('uhc_portal', 'UnitedHealthcare Portal', 'payer', 'web'),
    ('aetna_portal', 'Aetna Provider Portal', 'payer', 'web'),
    ('medicaid_phone', 'State Medicaid Phone', 'payer', 'phone')
ON CONFLICT (code) DO NOTHING;

-- Sample task types
INSERT INTO task_type (domain, action, display_name, description) VALUES
    ('eligibility', 'check', 'Eligibility Verification', 'Verify patient eligibility and benefits'),
    ('prior_auth', 'submit', 'Prior Auth Submission', 'Submit new prior authorization request'),
    ('prior_auth', 'check_status', 'Prior Auth Status', 'Check status of existing prior auth'),
    ('claim', 'submit_claim', 'Claim Submission', 'Submit new insurance claim'),
    ('claim', 'check_status', 'Claim Status', 'Check status of submitted claim')
ON CONFLICT (domain, action) DO NOTHING;

-- ================================================================
-- INDEXES SUMMARY
-- ================================================================

-- Performance indexes are created inline with tables above
-- Additional indexes can be added based on query patterns

-- ================================================================
-- GRANTS (Customize based on your roles)
-- ================================================================

-- GRANT USAGE ON SCHEMA public TO rcm_app_role;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO rcm_app_role;
-- GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO rcm_app_role;